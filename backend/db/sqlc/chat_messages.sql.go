// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: chat_messages.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countPublicSessionMessages = `-- name: CountPublicSessionMessages :one
SELECT COUNT(*) FROM chat_messages m
JOIN chat_sessions s ON m.session_id = s.id
WHERE m.session_id = $1 AND s.is_public = true
`

func (q *Queries) CountPublicSessionMessages(ctx context.Context, sessionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPublicSessionMessages, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSessionMessages = `-- name: CountSessionMessages :one
SELECT COUNT(*) FROM chat_messages m
JOIN chat_sessions s ON m.session_id = s.id
WHERE m.session_id = $1 AND s.user_id = $2
`

type CountSessionMessagesParams struct {
	SessionID uuid.UUID `json:"session_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) CountSessionMessages(ctx context.Context, arg CountSessionMessagesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSessionMessages, arg.SessionID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (
  id,
  session_id,
  role,
  content,
  created_at
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, session_id, role, content, created_at
`

type CreateChatMessageParams struct {
	ID        uuid.UUID `json:"id"`
	SessionID uuid.UUID `json:"session_id"`
	Role      string    `json:"role"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ID,
		arg.SessionID,
		arg.Role,
		arg.Content,
		arg.CreatedAt,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Role,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const deletePublicSessionMessages = `-- name: DeletePublicSessionMessages :exec
DELETE FROM chat_messages m
USING chat_sessions s
WHERE m.session_id = $1 
AND s.id = m.session_id 
AND s.is_public = true
`

func (q *Queries) DeletePublicSessionMessages(ctx context.Context, sessionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePublicSessionMessages, sessionID)
	return err
}

const deleteSessionMessages = `-- name: DeleteSessionMessages :exec
DELETE FROM chat_messages m
USING chat_sessions s
WHERE m.session_id = $1 
AND s.id = m.session_id 
AND s.user_id = $2
`

type DeleteSessionMessagesParams struct {
	SessionID uuid.UUID `json:"session_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteSessionMessages(ctx context.Context, arg DeleteSessionMessagesParams) error {
	_, err := q.db.Exec(ctx, deleteSessionMessages, arg.SessionID, arg.UserID)
	return err
}

const getChatMessage = `-- name: GetChatMessage :one
SELECT m.id, m.session_id, m.role, m.content, m.created_at FROM chat_messages m
JOIN chat_sessions s ON m.session_id = s.id
WHERE m.id = $1 AND s.user_id = $2
LIMIT 1
`

type GetChatMessageParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetChatMessage(ctx context.Context, arg GetChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, getChatMessage, arg.ID, arg.UserID)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Role,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const getLastPublicSessionMessage = `-- name: GetLastPublicSessionMessage :one
SELECT m.id, m.session_id, m.role, m.content, m.created_at FROM chat_messages m
JOIN chat_sessions s ON m.session_id = s.id
WHERE m.session_id = $1 AND s.is_public = true
ORDER BY m.created_at DESC
LIMIT 1
`

func (q *Queries) GetLastPublicSessionMessage(ctx context.Context, sessionID uuid.UUID) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, getLastPublicSessionMessage, sessionID)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Role,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const getLastSessionMessage = `-- name: GetLastSessionMessage :one
SELECT m.id, m.session_id, m.role, m.content, m.created_at FROM chat_messages m
JOIN chat_sessions s ON m.session_id = s.id
WHERE m.session_id = $1 AND s.user_id = $2
ORDER BY m.created_at DESC
LIMIT 1
`

type GetLastSessionMessageParams struct {
	SessionID uuid.UUID `json:"session_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) GetLastSessionMessage(ctx context.Context, arg GetLastSessionMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, getLastSessionMessage, arg.SessionID, arg.UserID)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Role,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const getPublicChatMessage = `-- name: GetPublicChatMessage :one
SELECT m.id, m.session_id, m.role, m.content, m.created_at FROM chat_messages m
JOIN chat_sessions s ON m.session_id = s.id
WHERE m.id = $1 AND s.is_public = true
LIMIT 1
`

func (q *Queries) GetPublicChatMessage(ctx context.Context, id uuid.UUID) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, getPublicChatMessage, id)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Role,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const listPublicSessionMessages = `-- name: ListPublicSessionMessages :many
SELECT m.id, m.session_id, m.role, m.content, m.created_at FROM chat_messages m
JOIN chat_sessions s ON m.session_id = s.id
WHERE m.session_id = $1 AND s.is_public = true
ORDER BY m.created_at DESC
`

func (q *Queries) ListPublicSessionMessages(ctx context.Context, sessionID uuid.UUID) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, listPublicSessionMessages, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatMessage{}
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionMessages = `-- name: ListSessionMessages :many
SELECT m.id, m.session_id, m.role, m.content, m.created_at FROM chat_messages m
JOIN chat_sessions s ON m.session_id = s.id
WHERE m.session_id = $1 AND s.user_id = $2
ORDER BY m.created_at ASC
`

type ListSessionMessagesParams struct {
	SessionID uuid.UUID `json:"session_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) ListSessionMessages(ctx context.Context, arg ListSessionMessagesParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, listSessionMessages, arg.SessionID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatMessage{}
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
